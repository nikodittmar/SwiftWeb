//
//  Parser.swift
//  SwiftWeb
//
//  Created by Niko Dittmar on 6/26/25.
//

/// A namespace for the template parser.
enum Parser {
    
    /// Parses a sequence of ``Token`` instances into an Abstract Syntax Tree (AST).
    ///
    /// This function serves as the main entry point for the parsing process. It initializes
    /// the internal parser implementation and passes the tokens to it.
    ///
    /// - Parameter tokens: An array of ``Token``s generated by the ``Tokenizer``.
    /// - Returns: An array of ``ASTNode``s representing the root of the parsed template.
    /// - Throws: A ``ParserError`` if the token sequence is malformed or violates
    ///   the grammar of the templating language.
    static func parse(_ tokens: [Token]) throws -> [ASTNode] {
        var parser = ParserImpl()
        return try parser.parse(tokens)
    }
}

/// An error that occurs during the parsing phase.
enum ParserError: Error {
    /// Thrown when a closing bracket does not match its corresponding opening bracket,
   /// or when brackets are left unclosed at the end of the template.
   /// Example: `if condition { ( } )`
    case invalidBrackets
    
    /// Thrown when the sequence of tokens violates the language's grammar.
    ///
    /// This is a general-purpose error for issues like missing conditions,
    /// unexpected keywords, or incomplete statements.
    /// Example: `if {`, `for in collection`, `<% } for ... %>`
    case syntaxError
}

// MARK: - Private Implementation

private struct ParserImpl {
    private var syntaxTree: [ASTNode] = []
    private var brackets: [Bracket] = []
    
    mutating public func parse(_ tokens: [Token]) throws -> [ASTNode] {
        resetState()
        
        for token in tokens {
            closedBrace = false
            
            switch token {
            case .code(let code):
                returning = false
                try add(code)
            case .expression(let expression):
                returning = true
                try add(expression)
            case .text(let text):
                if openParenthesis() { throw ParserError.invalidBrackets }
                try syntaxTree.addNode(.text(text), depth: brackets.count)
            }
        }
        
        guard brackets.isEmpty else {
            throw ParserError.invalidBrackets
        }
        
        guard buffer.isEmpty else {
            throw ParserError.syntaxError
        }
        
        return syntaxTree
    }
    
    mutating private func resetState() {
        syntaxTree = []
        brackets = []
        buffer = []
        current = ParserImpl.syntaxHandlers
        closedBrace = false
        returning = false
    }
    
    mutating private func addBracket(_ bracket: Bracket) throws {
        switch bracket {
        case .left(.parenthesis):
            brackets.append(bracket)
        case .left(.brace):
            // Braces may not be within parenthesis
            if let top = brackets.last {
                guard case .brace = top.type else { throw ParserError.invalidBrackets }
            }
            brackets.append(bracket)
        case .right:
            guard let top = brackets.last else { throw ParserError.invalidBrackets }
            guard bracket == top.opposite else { throw ParserError.invalidBrackets }
            
            brackets.removeLast()
        }
    }
    
    private func openParenthesis() -> Bool {
        return !brackets.isEmpty && brackets.last?.type == .parenthesis
    }
    
    private var buffer: [ExpressionToken] = []
    private var current: SyntaxNode = syntaxHandlers

    private var closedBrace: Bool = false
    private var returning: Bool = false
    
    mutating private func add(_ line: String) throws {
        let tokens: [ExpressionToken] = Scanner.scan(line)
                        
        for token in tokens {
            switch token {
            case .keyword(let keyword):
                if openParenthesis() { throw ParserError.invalidBrackets }
                guard let next = current.keywords[keyword] else { throw ParserError.syntaxError }
                current = next
                buffer.append(token)
            case .identifier:
                guard let next = current.identifier else { throw ParserError.syntaxError }
                current = next
                buffer.append(token)
            case .leftParen:
                try addBracket(.left(.parenthesis))
            case .rightParen:
                try addBracket(.right(.parenthesis))
            case .leftBrace:
                guard let handler = current.handler else { throw ParserError.syntaxError }
                try handler(&self)
                buffer = []
                current = ParserImpl.syntaxHandlers
                try addBracket(.left(.brace))
            case .rightBrace:
                try addBracket(.right(.brace))
                closedBrace = true
            }
        }
        
        if !buffer.isEmpty && returning {
            guard let handler = current.handler else {
                throw ParserError.syntaxError
            }
            try handler(&self)
            
            buffer = []
            current = ParserImpl.syntaxHandlers
        }
    }
    
    
    
    private typealias SyntaxHandler = @Sendable (inout ParserImpl) throws -> Void
    
    private final class SyntaxNode: Sendable {
        let keywords: [Keyword: SyntaxNode]
        let identifier: SyntaxNode?
        let handler: SyntaxHandler?
        
        init(keywords: [Keyword : SyntaxNode], identifier: SyntaxNode?, handler: SyntaxHandler?) {
            self.keywords = keywords
            self.identifier = identifier
            self.handler = handler
        }
    }
    
    private static let syntaxHandlers: SyntaxNode = SyntaxNode(
        keywords: [
            .if : SyntaxNode(
                keywords: [:],
                identifier: SyntaxNode(
                    keywords: [:],
                    identifier: nil,
                    handler: { parser in
                        try parser.ifHandler()
                    }
                ),
                handler: nil
            ),
            .else: SyntaxNode(
                keywords: [
                    .if: SyntaxNode(
                        keywords: [:],
                        identifier: SyntaxNode(
                            keywords: [:],
                            identifier: nil,
                            handler: { parser in
                                try parser.elseIfHandler()
                            }
                        ),
                        handler: nil
                    )
                ],
                identifier: nil,
                handler: { parser in
                    try parser.elseHandler()
                }
            ),
            .for: SyntaxNode(
                keywords: [:],
                identifier: SyntaxNode(
                    keywords: [
                        .in: SyntaxNode(
                            keywords: [:],
                            identifier: SyntaxNode(
                                keywords: [:],
                                identifier: nil,
                                handler: { parser in
                                    try parser.forInHandler()
                                }
                            ),
                            handler: nil
                        )
                    ],
                    identifier: nil,
                    handler: nil
                ),
                handler: nil
            ),
        ],
        identifier: SyntaxNode(
            keywords: [:],
            identifier: nil,
            handler: { parser in
                try parser.expressionHandler()
            }
        ),
        handler: nil
    )
    
    mutating func ifHandler() throws {
        if closedBrace { throw ParserError.syntaxError }
        
        guard buffer.count == 2 else { throw ParserError.syntaxError }
        
        guard case .identifier(let condition) = buffer[1] else { throw ParserError.syntaxError }
        
        let node: ASTNode = .conditional(branches: [
            Branch(condition: condition, body: [])
        ], alternative: nil)
        
        try syntaxTree.addNode(node, depth: brackets.count)
    }
    
    mutating func elseIfHandler() throws {
        guard buffer.count == 3 else { throw ParserError.syntaxError }
        
        guard case .identifier(let condition) = buffer[2] else { throw ParserError.syntaxError }
        
        try syntaxTree.addBranch(Branch(condition: condition, body: []), depth: brackets.count)
    }
    
    mutating func elseHandler() throws {
        guard buffer.count == 1 else { throw ParserError.syntaxError }
        
        try syntaxTree.addAlternative(depth: brackets.count)
    }
    
    mutating func forInHandler() throws {
        if closedBrace { throw ParserError.syntaxError }
        
        guard buffer.count == 4 else { throw ParserError.syntaxError }
        
        guard case .identifier(let variable) = buffer[1] else { throw ParserError.syntaxError }
        guard case .identifier(let collection) = buffer[3] else { throw ParserError.syntaxError }
        
        if openParenthesis() { throw ParserError.invalidBrackets }
        
        let node: ASTNode = .loop(variable: variable, collection: collection, body: [])
        
        try syntaxTree.addNode(node, depth: brackets.count)
    }
    
    mutating func expressionHandler() throws {
        if closedBrace { throw ParserError.syntaxError }
        
        guard buffer.count == 1 else { throw ParserError.syntaxError }
        guard returning else { throw ParserError.syntaxError }
        guard case .identifier(let identifier) = buffer[0] else { throw ParserError.syntaxError }
        
        if openParenthesis() { throw ParserError.invalidBrackets }
        try syntaxTree.addNode(.expression(identifier), depth: brackets.count)
    }

}

private enum Bracket: Equatable {
    case left(BracketType)
    case right(BracketType)
    
    enum BracketType: Equatable {
        case brace
        case parenthesis
    }
    
    var opposite: Bracket {
        switch self {
        case .left(let type):
            return .right(type)
        case .right(let type):
            return .left(type)
        }
    }
    
    var type: BracketType {
        switch self {
        case .left(let type), .right(let type):
            return type
        }
    }
}
